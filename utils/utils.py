from typing import Optional

import pandas as pd
import numpy as np
from scipy import stats

# Selecting suites
suites = {
    'irregular': ['astar', 'bfs', 'cc', 'mcf', 'omnetpp', 'pr', 'soplex', 
                  'sphinx3', 'xalancbmk'],

    'spec06': ['astar', 'bwaves', 'cactusADM', 'gcc', 'GemsFDTD', 'lbm', 
               'leslie3d', 'libquantum', 'mcf', 'milc', 'omnetpp', 
               'soplex', 'sphinx3', 'xalancbmk', 'zeusmp'],
               # The below benchmarks have <= 2 LLC MPKI on the baseline.
               #'bzip2', 'calculix', 'gobmk', 'gromacs', 'h264ref', 
               #'hmmer', 'perlbench', 'tonto', 'wrf'],

    'spec17': ['602.gcc', '605.mcf', '607.cactuBSSN', '619.lbm', '620.omnetpp',
               '627.cam4', '649.fotonik3d', '623.xalancbmk', '628.pop2'],
               # The below benchmarks have <= 2 LLC MPKI on the baseline.
               # '600.perlbench', '603.bwaves', '621.wrf', 
               # '625.x264', '631.deepsjeng', '638.imagick', 
               # '641.leela', '644.nab', '648.exchange2', '654.roms', 
               # '657.xz'],

    'gap': ['bc', 'bfs', 'cc', 'pr', 'sssp', 'tc'],
    'google': ['charlie', 'delta', 'merced', 'whiskey'],
    'cloudsuite': ['cassandra', 'classifcation', 'cloud9', 'nutch', 'streaming'],

    # Experimental
    'action_ordering': ['GemsFDTD', 'libquantum', 'leslie3d', 'sphinx3', 'bfs', 'cc'],
                       # The below benchmarks were also evaluated.
                       # 'gcc', 'GemsFDTD', 'lbm', 'leslie3d', 'libquantum',
                       # 'soplex', 'sphinx3', 'bfs', 'cc', 'sssp', 'delta',
                       # 'merced', 'cloud9']
}
suites['mixes'] = [f'mix{i}' for i in range(0, 100)]

# Selecting phases
phases = {}
phases['one_phase'] = {
    # SPEC 06
    'astar': '313B',
    'bwaves': '1861B',
    'bzip2': '183B',
    'cactusADM': '734B',
    'calculix': '2670B',
    'gcc': '13B',
    'GemsFDTD': '109B',
    'gobmk': '135B',
    'gromacs': '1B',
    'h264ref': '273B',
    'hmmer': '7B',
    'lbm': '94B',
    'leslie3d': '1116B',
    'libquantum': '1210B',
    'mcf': '46B',
    'milc': '360B',
    'omnetpp': '340B',
    'perlbench': '53B',
    'soplex': '66B',
    'sphinx3': '2520B',
    'tonto': '2834B',
    'wrf': '1212B',
    'xalancbmk': '99B',
    'zeusmp': '600B',
    # SPEC 17
    '600.perlbench': '210B',
    '602.gcc': '734B',
    '603.bwaves': '3699B',
    '605.mcf': '665B',
    '607.cactuBSSN': '2421B',
    '619.lbm': '4268B',
    '620.omnetpp': '874B',
    '621.wrf': '575B',
    '623.xalancbmk': '700B',
    '625.x264': '18B',
    '627.cam4': '573B',
    '628.pop2': '17B',
    '631.deepsjeng': '928B',
    '638.imagick': '10316B',
    '641.leela': '800B',
    '644.nab': '5835B',
    '648.exchange2': '1699B',
    '649.fotonik3d': '1176B',
    '654.roms': '842B',
    '657.xz': '3167B',
    # GAP
    'bc': 'default',
    'bfs': 'default',
    'cc': 'default',
    'pr': 'default',
    'sssp': 'default',
    'tc': 'default',
    # Google
    'charlie': 'default',
    'delta': 'default',
    'merced': 'default',
    'whiskey': 'default',
    # Cloudsuite
    'cassandra': 'phase0',
    'classifcation': 'phase0',
    'cloud9': 'phase0',
    'nutch': 'phase0',
    'streaming': 'phase0',
}
phases['weighted'] = {k: ('weighted' if phases['one_phase'][k] != 'default' else 'default') for k in phases['one_phase']}
phases['weighted'] |= {f'mix{i}': 'default' for i in range(0, 100)}
phases['one_phase'] |= {f'mix{i}': 'default' for i in range(0, 100)}


def read_data_file(path: str):
    """Read a stats csv generated by the evaluate script in Pythia/experiments.

    Parameters:
        path: Path to the csv file.

    Returns:
        df: A minimally-processed dataframe of the stats csv.
    """
    df = pd.read_csv(path)

    # Fill nan values
    simpoint_cols = [f'cpu{cpu}_simpoint' for cpu in range(max(df.num_cpus))]
    df[simpoint_cols] = df[simpoint_cols].fillna('default')

    # Clean prefetcher names, fix prefetcher ordering
    for col in ['L1D_pref', 'L2C_pref', 'LLC_pref']:
        df[col] = df[col].replace({
            'cygnus_state': 'cygnusstate',
            'from_file': 'fromfile',
            'ip_stride': 'ipstride',
            'isb_ideal': 'isbideal',
            'isb_real': 'isbreal',
            'next_line': 'nextline',
            'spp_dev2': 'sppdev2',
            'spp_ppf_dev': 'sppppfdev',
        }, regex=True)

        # Fix prefetcher ordering
        df[col] = df[col].apply(lambda c: '_'.join(sorted(c.split('_'))))

        # Unfix some orderings
        df[col] = df[col].replace({
            'cygnusstate': 'cygnus_state',
            'fromfile': 'from_file',
            'ipstride': 'ip_stride',
            'isbideal': 'isb_ideal',
            'isbreal': 'isb_real',
            'nextline': 'next_line',
            'sppdev2': 'spp_dev2',
            'sppppfdev': 'spp_ppf_dev',
        })

    # Make all_pref follow cleaned prefetcher names
    df.all_pref = list(zip(df.L1D_pref, df.L2C_pref, df.LLC_pref))
    return df

def mean(values: np.ndarray, metric: str, 
         weights: Optional[np.ndarray] = None):
    """Compute the mean of a particular metric, with the right formula.

    Parameters:
        values: A list of values.
        metric: A string of the metric, for selecting the right formula.
        weights: A list of weights, for weighted averages.

    Returns:
        mean: The mean of the values.    
    """
    if type(weights) is np.ndarray:
        assert np.isclose(np.sum(weights), 1), 'Weights should sum to 1'
    # ipc_improvement: gmean
    if 'ipc_improvement' in metric:
        # Add 100 to prevent negative values (so that 100 = no prefetcher baseline)
        return stats.gmean(values + 100, weights=weights) - 100
    # mpki_reduction: gmean
    if 'mpki_reduction' in metric:
        # Take gmean of relative misses instead of MPKI reduction to prevent negative values
        return 100 - stats.gmean(100 - values, weights=weights)
    # Others: amean
    else:
        return np.average(values, weights=weights)

def get_mean_type(metric: str) -> str:
    """Return the type of mean (amean/gmean) as a string."""
    if 'ipc_improvement' in metric or 'mpki_reduction' in metric:
        return 'gmean'
    else:
        return 'amean'

def clean_trace_name(trace_name: str, metric: Optional[str] = "") -> str:
    """Clean a trace name for plotting."""
    tr = trace_name.split('_')
    if len(tr) == 1:
        tr = tr[0]
        if tr == 'mean' and metric != '':
            tr = get_mean_type(metric)
    else:
        tr = '_'.join(tr[:-1])
    return tr